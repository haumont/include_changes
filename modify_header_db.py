#!/usr/bin/env python3

# Change the earlier written modify_header python program to instead of taking
# the header path parameter, take the above generated Berkeley database
# filename, and change the include file name from the base name to the full
# path in the database value instead of adding the header path to the
# beginning.  Do not modify includes of the style '#include <', only includes
# of the style '#include " '. If the include includes part of the path in the
# database file, for example '#include "dialogs/first.h", and the database
# contains a key of "first.h" with a value of "base/dialogs/first.h",  then
# alter the include to "base/dialogs/first.h".  If the path does not match,
# for example, if the include was "places/first.h" and the value was
# still "base/dialogs/first.h", the change the include to
# a '#error "places/first.h" was included but found
# as "base/dialogs/first.h"' and also print an error message to standard
# error, but continue to parse the file

# Add a -h (--help also) option to the last modify_header.py and
# add_to_database.py, and also display that help if incorrect parameters are
# specified

import argparse
import os
import re
import sys
import bsddb

def modify_header_db(database_filename, source_file):
    # Open the Berkeley database
    db = bsddb.hashopen(database_filename)

    # Compile a regular expression to match '#include "filename"'
    include_re = re.compile(r'^\s*#include\s+"(.*)"\s*$')

    with open(source_file) as f:
        for line in f:
            # Match '#include "filename"'
            match = include_re.match(line)
            if match:
                include_filename = match.group(1)

                # Look up the file in the database
                if include_filename in db:
                    include_path = db[include_filename]
                    include_path = os.path.normpath(include_path)
                    if os.path.exists(include_path):
                        # Replace the include with the full path
                        line = line.replace(include_filename, include_path)
                    else:
                        # File not found, display error
                        sys.stderr.write(f'Error: {include_path} not found\n')
                        line = f'#error "{include_filename}" was included but found as "{include_path}"'

            # Write the modified or unmodified line to stdout
            sys.stdout.write(line)

    # Close the database
    db.close()

def main():
    parser = argparse.ArgumentParser(description='Modify #include statements in a C/C++ source file to use full path')
    parser.add_argument('database', help='Berkeley database file to use for path lookups')
    parser.add_argument('source', help='C/C++ source file to modify')
    args = parser.parse_args()

    if args.database == '-h' or args.source == '-h' or args.database == '--help' or args.source == '--help':
        parser.print_help()
    else:
        modify_header_db(args.database, args.source)

if __name__ == '__main__':
    main()

# To use this program, you can save the above code to a file named
# modify_header_db.py, and run it from the command line with the following
# command:

# python modify_header_db.py <database_path> <file_path>

# Where <database_path> is the path to the Berkeley database file generated by
# the previous program, and <file_path> is the path to the C/C++ file to
# modify. The program will modify #include statements of the
# style #include "..." to use the full path from the database value instead
# of just the base name, and will handle cases where the included file name
# partially matches a key in the database, or does not match at all. If an
# error is encountered, the program will print an error message to standard
# error and continue to parse the file.

